module rx_module#(
  parameter integer DATA_WIDTH = 8,
  parameter integer FIFO_DEPTH = 32,
  parameter integer BAUD_DIV_MAX = 48 // 1 Mbps için (48 MHz / 1 Mbps)
) (
  input clk,
  input rst,
  input [DATA_WIDTH-1:0] rx_in,
  input rx_en,
  output reg [DATA_WIDTH-1:0] rx_data_out,
  output reg rx_buffer_empty,
  output reg rx_error
);

  // RX arabelleği
  reg [DATA_WIDTH-1:0] rx_buffer [FIFO_DEPTH-1:0];
  // RX yazma işaretçisi
  reg [LOG2(FIFO_DEPTH)-1:0] rx_wr_ptr;
  // RX okuma işaretçisi
  reg [LOG2(FIFO_DEPTH)-1:0] rx_rd_ptr;
  // RX durum değişkenleri
  reg rx_start_bit;
  reg rx_data_valid;
  reg rx_error_flag;
  // RX kenar algılama sayaçları
  reg [3:0] clk_count_startbit;
  reg [3:0] clk_count_databit;
  reg [3:0] clk_count_stopbit;

  // Baud hızı sayaçları
  reg [BAUD_DIV_MAX-1:0] baud_cnt_rx;
  reg baud_pulse_rx;

  // Kenar algılama için sayaçları sıfırla
  always @(posedge clk) begin
    if (rst) begin
      clk_count_startbit <= 0;
      clk_count_databit <= 0;
      clk_count_stopbit <= 0;
      baud_cnt_rx <= 0;
    end
  end

  // Baud hızı güncelle
  always @(posedge clk) begin
    if (rst) begin
      baud_cnt_rx <= 0;
    end else begin
      if (rx_en) begin
        baud_cnt_rx <= baud_cnt_rx + 1;
        if (baud_cnt_rx == rx_en) begin // baud_rate_in ile değiştir
          baud_pulse_rx <= 1;
          baud_cnt_rx <= 0; // Baud dönemi sıfırla
        end else begin
          baud_pulse_rx <= 0;
        end
      end
    end
  end

  // RX işlemleri
  always @(posedge clk) begin
    if (rst) begin
      rx_wr_ptr <= 0;
      rx_rd_ptr <= 0;
      rx_start_bit <= 0;
      rx_data_valid <= 0;
      rx_error_flag <= 0;
    end else begin
      if (rx_en) begin
        // Başlangıç bitini algıla
        if (~rx_start_bit && baud_pulse_rx && rx_in == 1'b0) begin
          clk_count_startbit <= 1;
        end else begin
          clk_count_startbit <= 0; // Başlangıç biti algılandıktan sonra sıfırla
        end

        // Veri bitlerini al
        if (rx_start_bit && baud_pulse_rx && rx_valid) begin
          clk_count_databit <= clk_count_databit + 1;
          if (clk_count_databit == DATA_WIDTH) begin // Veri bitleri için DATA_WIDTH kullan
            rx_buffer[rx_wr_ptr] <= rx_in;
            rx_wr_ptr <= rx_wr_ptr + 1;
            if (rx_wr_ptr == FIFO_DEPTH) begin
              rx_wr_ptr <= 0;
            end
            rx_data_valid <= 1;
            clk_count_databit <= 0;
          end
        end else begin
          clk_count_databit <= 0; // Veri bitleri bitmiyorsa sıfırla
        end

 // Durma bitini algıla
if (rx_start_bit && ~baud_pulse_rx) begin
  clk_count_stopbit <= clk_count_stopbit + 1;
  if (clk_count_stopbit == 1) begin // 1 bitlik durma biti yeterli
    // Veri alımı tamamlandı, hata yok
    rx_error_flag <= 0;
    rx_start_bit <= 0; // Bir sonraki karakter için hazırla
  end else if (clk_count_stopbit > 1) begin
    // Fazla durma biti: hata
    rx_error_flag <= 1;
    rx_start_bit <= 0; // Bir sonraki karakter için hazırla
  end
end

// RX çıkış verisi
assign rx_data_out = (rx_data_valid) ? rx_buffer[rx_rd_ptr] : 8'bzzzzzzzz; //yüksek empedans

// RX arabellek okuma işlemi
always @(posedge clk) begin
  if (rx_en && rx_data_valid) begin
    rx_rd_ptr <= rx_rd_ptr + 1;
    if (rx_rd_ptr == FIFO_DEPTH) begin
      rx_rd_ptr <= 0;
    end
    rx_data_valid <= 0; // Bir sonraki okunmaya hazırlan
  end
end

// RX arabellek durumu
assign rx_buffer_empty = (rx_wr_ptr == rx_rd_ptr);

endmodule
    

